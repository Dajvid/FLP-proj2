# Rubik's cube solver (flp20-log)
Rubik's cube solver is supposed to solve instances of Rubik's cube puzzle.
This is a school project for [FLP](https://www.fit.vut.cz/study/course/13926/.en)
course at [BUT FIT](https://www.fit.vut.cz/.en) in the academic year 2020/2021.

## Compilation
The solver can be compiled by `make` command from a project root directory. Dependencies for compilation are `make` and `swipl` utilities.

## Execution
After compilation solver can be run as:

    ./flp20-log
Afterward, input is expected on standard input in form of a 2D cube net. Example input:

    uuu
    uuu
    uuu
    fff rrr bbb lll
    fff rrr bbb lll
    fff rrr bbb lll
    ddd
    ddd
    ddd
Where:
-   `u` represents the upper side,
-   `f` represents the front side,
-   `r` represents the right side,
-   `b` represents the back side,
-   `l` represents the left side,
-   `d` represents the bottom side.

Input is not validated, so be sure to provide only valid Rubik's cube instances.

## Implementation
I implemented two approaches using blind space state search methods, Iterative Deepening Search (IDS) and Bredth First Search (BFS).

### Modules
Implementation consist of the following modules located in `src` directory:
-   RubikMain with the main rule, which is the entry point for the whole program,
-   RubikIO for reading and printing of rubik's cube instances,
-   RubikRotations holds predicates that represent possible moves,
-   RubikIDS with the implementation of IDS state-space search algorithm,
-   RubikBFS with the implementation of BFS state-space search algorithm.

## Test suite
Test inputs are located in the `cubes` folder inside the project root. The test suite consists of multiple cube instances each solvable in a different minimum number of moves. A minimal number of moves is also mentioned in the input's filename.

Each input was generated by N random moves from the solved cube (consecutive opposite moves were not allowed). The program used to generate inputs is located in `cubes/RubikScramble.pl` and can be compiled by `make scramble` in a project's root directory. Afterward, I also verified if the minimum number of moves needed to solve the cube corresponds to N (number of moves used to generate the cube instance).

## Results
I measured the computation time it takes to solve each puzzle from the `cubes` folder with increasing difficulty. Measurements were made on the merlin server using the `time` utility. BFS exceeded the runtime threshold of 30 minutes, given by merlin, and hence could not be finished on merlin for inputs harder than 4 moves, same holds for IDS and inputs harder than 8 moves.

| Optimal solution | IDS [s] | BFS [s] |
|:----------------:|:-------:|:-------:|
|       1 move     |  0.019  |  0.019  |
|      2 moves     |  0.019  |  0.031  |
|      3 moves     |  0.021  |  0.689  |
|      4 moves     |  0.041  | 277.824 |
|      5 moves     |  0.074  |    -    |
|      6 moves     |  4.093  |    -    |
|      7 moves     |  32.46  |    -    |
|      8 moves     | 625.852 |    -    |

## Conclusion
I implemented a functional brute force solver, that should be able to solve any solvable instance of Rubik's cube (sometimes after few days..) without exceeding stack limit thanks to small memory requirements of IDS algorithm and the fact that any valid instance of Rubik's cube should be solvable in 20 moves (although I'm not using full moves, but only moves of each face by +-90). While solving this problem I became quite curious about how to do it quickly and efficiently, and I wanted to precompute the heuristic function based on the manhattan distance of corner pieces and use an informed IDA* search, which should be a very good approach to a problem like this. I basically wanted to implement the approach described in this [paper](https://www.cs.princeton.edu/courses/archive/fall06/cos402/papers/korfrubik.pdf) in prolog, but due to other projects, I didn't find enough time. Although let me know if you would like to see something like this even after the project deadline, I will probably get to it when I have some time.
